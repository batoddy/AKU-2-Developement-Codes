/*
 * aku_infra_imu.c
 *
 *  Created on: Jan 30, 2024
 *      Author: Batuhan
 */

#include "main.h"
#include "aku_config.h"
#include "aku_structure.h"
#include "aku_infrastructure.h"
#include "aku_infra_imu.h"
#include "math.h"
// include imu library files:---------
// -------------------- USER CODE 0 BEGIN ---------------------
#include "bno055.h"
#include "bno055_stm32.h"
// --------------------- USER CODE 0 END ---------------------
IMU_Device bno055 = {
	.i2c = IMU_I2C,
	.addr = IMU_ADDR,
	.chip_id = IMU_CHIP_ID,
	.chip_id_reg = IMU_CHIP_ID_ADDR,
	.offset_val = IMU_OFFSET_VAL,
	.empty_reg_val = IMU_EMPTY_REG_VAL,
	.set_offset = SET_OFFSET,
	.sys_status = SYS_STATUS_REG,
	.sys_err = SYS_ERR_REG};

static IMU imu;
static IMU imu_offset_data;

void config_IMU();
void read_imu_data(IMU *imu_data);
void empty_imu_registers();
void get_offset_data(IMU *temp_imu_offset_data);
uint8_t check_imu_connection();
uint8_t check_imu_status();

//--------------------------------------------------------------
//--------------------------------------------------------------
// -------------------- USER CODE 1 BEGIN ---------------------
void imu_read_register(uint8_t reg, uint8_t *data, uint8_t len)
{ // write read from register func.
	HAL_I2C_Master_Transmit(bno055.i2c, bno055.addr << 1, &reg, 1,
							100);
	HAL_I2C_Master_Receive(bno055.i2c, bno055.addr << 1, data, len,
						   100);
}
void config_IMU() // write imu configuration func.
{
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);
	bno055_assignI2C(bno055.i2c);
	bno055_reset();
	bno055_setOperationModeNDOF();
	HAL_Delay(20);
}

void read_imu_data(IMU *imu_data) // write read data from imu func.
{

	bno055_vector_t accel = bno055_getVectorAccelerometer();
	bno055_vector_t gyro = bno055_getVectorGyroscope();
	bno055_vector_t euler = bno055_getVectorEuler();
	bno055_vector_t magno = bno055_getVectorMagnetometer();
	bno055_vector_t lineer_accel = bno055_getVectorLinearAccel();

	imu_data->accel.x = accel.x;
	imu_data->accel.y = accel.y;
	imu_data->accel.z = accel.z;

	imu_data->gyro.x = gyro.x;
	imu_data->gyro.y = gyro.y;
	imu_data->gyro.z = gyro.z;

	imu_data->magno.x = magno.x;
	imu_data->magno.y = magno.y;
	imu_data->magno.z = magno.z;

	imu_data->euler.yaw = euler.x;
	imu_data->euler.pitch = euler.y;
	imu_data->euler.roll = euler.z;

	imu_data->lineer_accel.x = lineer_accel.x;
	imu_data->lineer_accel.y = lineer_accel.y;
	imu_data->lineer_accel.z = lineer_accel.z;
	// ERROR CODES can be returned --dev note
}
// --------------------- USER CODE 1 END ---------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
void init_IMU()
{
	// IMU initialize code:----------
	config_IMU();
	empty_imu_registers();
	aku_delay(20);
	if (bno055.set_offset)
	{
		get_offset_data(&imu_offset_data);
	}
	//-------------------------------
}

IMU *read_IMU()
{
	// imu.data_flow_flag = check_imu_connection();
	// imu.dev_status = check_imu_status();
	read_imu_data(&imu);
	imu.dataflow_rate = aku_chronometer(&imu.tick);
	if (bno055.set_offset)
	{
		imu.accel.x = imu.accel.x - imu_offset_data.accel.x;
		imu.accel.y = imu.accel.y - imu_offset_data.accel.y;
		imu.accel.z = imu.accel.z - imu_offset_data.accel.z;

		imu.gyro.x = imu.gyro.x - imu_offset_data.gyro.x;
		imu.gyro.y = imu.gyro.y - imu_offset_data.gyro.y;
		imu.gyro.z = imu.gyro.z - imu_offset_data.gyro.z;

		imu.euler.yaw = imu.euler.yaw - imu_offset_data.euler.yaw;
		imu.euler.pitch = imu.euler.pitch - imu_offset_data.euler.pitch;
		imu.euler.roll = imu.euler.roll - imu_offset_data.euler.roll;

		imu.lineer_accel.x = imu.lineer_accel.x - imu_offset_data.lineer_accel.x;
		imu.lineer_accel.y = imu.lineer_accel.y - imu_offset_data.lineer_accel.y;
		imu.lineer_accel.z = imu.lineer_accel.z - imu_offset_data.lineer_accel.z;
	}
	imu.accel.resultant = sqrt(pow(imu.accel.x, 2) + pow(imu.accel.y, 2) + pow(imu.accel.z, 2));
	return (&imu);
}

void empty_imu_registers()
{
	uint16_t ctr;
	for (ctr = 0; ctr < bno055.empty_reg_val; ctr++)
	{
		read_imu_data(&imu);
	}
}

void get_offset_data(IMU *temp_imu_offset_data)
{
	uint16_t ctr;
	IMU offset_data;
	for (ctr = 0; ctr < bno055.offset_val; ctr++)
	{
		read_imu_data(&offset_data);
		temp_imu_offset_data->accel.x = temp_imu_offset_data->accel.x + offset_data.accel.x;
		temp_imu_offset_data->accel.y = temp_imu_offset_data->accel.y + offset_data.accel.y;
		temp_imu_offset_data->accel.z = temp_imu_offset_data->accel.z + offset_data.accel.z;

		temp_imu_offset_data->gyro.x = temp_imu_offset_data->gyro.x + offset_data.gyro.x;
		temp_imu_offset_data->gyro.y = temp_imu_offset_data->gyro.y + offset_data.gyro.y;
		temp_imu_offset_data->gyro.z = temp_imu_offset_data->gyro.z + offset_data.gyro.z;

		temp_imu_offset_data->euler.yaw = temp_imu_offset_data->euler.yaw + offset_data.euler.yaw;
		temp_imu_offset_data->euler.pitch = temp_imu_offset_data->euler.pitch + offset_data.euler.pitch;
		temp_imu_offset_data->euler.roll = temp_imu_offset_data->euler.roll + offset_data.euler.roll;

		temp_imu_offset_data->lineer_accel.x = temp_imu_offset_data->lineer_accel.x + offset_data.lineer_accel.x;
		temp_imu_offset_data->lineer_accel.y = temp_imu_offset_data->lineer_accel.y + offset_data.lineer_accel.y;
		temp_imu_offset_data->lineer_accel.z = temp_imu_offset_data->lineer_accel.z + offset_data.lineer_accel.z;
	}

	temp_imu_offset_data->accel.x /= bno055.offset_val;
	temp_imu_offset_data->accel.y /= bno055.offset_val;
	temp_imu_offset_data->accel.z /= bno055.offset_val;

	temp_imu_offset_data->gyro.x /= bno055.offset_val;
	temp_imu_offset_data->gyro.y /= bno055.offset_val;
	temp_imu_offset_data->gyro.z /= bno055.offset_val;

	temp_imu_offset_data->euler.yaw /= bno055.offset_val;
	temp_imu_offset_data->euler.pitch /= bno055.offset_val;
	temp_imu_offset_data->euler.roll /= bno055.offset_val;

	temp_imu_offset_data->lineer_accel.x /= bno055.offset_val;
	temp_imu_offset_data->lineer_accel.y /= bno055.offset_val;
	temp_imu_offset_data->lineer_accel.z /= bno055.offset_val;
}

uint8_t check_imu_connection()
{
	uint8_t id;
	imu_read_register(bno055.chip_id_reg, &id, 1);
	return (id == bno055.chip_id) ? DEV_OK : DEV_ERR;
}

uint8_t check_imu_status()
{
	uint8_t reg_data;
	imu_read_register(bno055.sys_status, &reg_data, 1);
	return reg_data;
}
