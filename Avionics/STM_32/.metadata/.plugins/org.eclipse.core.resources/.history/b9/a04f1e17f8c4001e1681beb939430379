/*
 * aku_infra_imu.c
 *
 *  Created on: Jan 30, 2024
 *      Author: Batuhan
 */

#include "main.h"
#include "aku_config.h"
#include "aku_structure.h"
#include "aku_infrastructure.h"
#include "aku_infra_imu.h"
#include "math.h"
// include imu library files:---------
// -------------------- USER CODE 0 BEGIN ---------------------
#include "bno055.h"
#include "bno055_stm32.h"

IMU_Device bno055={
	.i2c = &hi2c1,
	.addr = 0x28,
	.chip_id = 0xA0,
	.chip_id_reg = 0x00,
	.offset_val = 250,
	.empty_reg_val = 250,
	.set_offset = 0,
	.sys_status = 0x39,
	.sys_err = 0x3A
};

#define OFFSET_VALUE bno055.offset_val
#define EMPTY_REG_VALUE bno055.empty_reg_val
#define SET_OFFSET_IMU bno055.set_offset // set 0 for not offseting, 1 for offseting
// --------------------- USER CODE 0 END ---------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
static IMU imu;
static IMU imu_offset_data;

void config_IMU();
void get_imu_data(IMU *imu_data);
void empty_imu_registers();
void get_offset_data(IMU *temp_imu_offset_data);
uint8_t check_imu_connection();
uint8_t check_imu_status();

//--------------------------------------------------------------
//--------------------------------------------------------------
// -------------------- USER CODE 1 BEGIN ---------------------
void imu_read_register(uint8_t reg, uint8_t *data, uint8_t len){ // write read from register func.
	  HAL_I2C_Master_Transmit(bno055.i2c, bno055.addr << 1, &reg, 1,
	                          100);
	  HAL_I2C_Master_Receive(bno055.i2c, bno055.addr << 1, data, len,
	                         100);
}
void config_IMU() // write imu configuration func.
{
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);
	bno055_assignI2C(bno055.i2c);
	bno055_reset();
	bno055_setOperationModeNDOF();
	HAL_Delay(20);
}

void get_imu_data(IMU *imu_data) // write read data from imu func.
{

	bno055_vector_t accel = bno055_getVectorAccelerometer();
	bno055_vector_t gyro = bno055_getVectorGyroscope();
	bno055_vector_t euler = bno055_getVectorEuler();
	bno055_vector_t magno = bno055_getVectorMagnetometer();
	bno055_vector_t lineer_accel = bno055_getVectorLinearAccel();

	imu_data->accel.x = accel.x;
	imu_data->accel.y = accel.y;
	imu_data->accel.z = accel.z;

	imu_data->gyro.x = gyro.x;
	imu_data->gyro.y = gyro.y;
	imu_data->gyro.z = gyro.z;

	imu_data->magno.x = magno.x;
	imu_data->magno.y = magno.y;
	imu_data->magno.z = magno.z;

	imu_data->euler.yaw = euler.x;
	imu_data->euler.pitch = euler.y;
	imu_data->euler.roll = euler.z;

	imu_data->lineer_accel.x = lineer_accel.x;
	imu_data->lineer_accel.y = lineer_accel.y;
	imu_data->lineer_accel.z = lineer_accel.z;
	// ERROR CODES can be returned --dev note
}
// --------------------- USER CODE 1 END ---------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
//--------------------------------------------------------------
void init_IMU()
{
	// IMU initialize code:----------
	config_IMU();
	empty_imu_registers();
	HAL_Delay(20);
	get_offset_data(&imu_offset_data);
	//-------------------------------
}

IMU *read_IMU()
{
	// imu.data_flow_flag = check_imu_connection();
	// imu.dev_status = check_imu_status();
	get_imu_data(&imu);
	imu.data_read_rate = aku_chronometer(&imu.tick);
	if (SET_OFFSET_IMU)
	{
		imu.accel.x = imu.accel.x - imu_offset_data.accel.x;
		imu.accel.y = imu.accel.y - imu_offset_data.accel.y;
		imu.accel.z = imu.accel.z - imu_offset_data.accel.z;

		imu.gyro.x = imu.gyro.x - imu_offset_data.gyro.x;
		imu.gyro.y = imu.gyro.y - imu_offset_data.gyro.y;
		imu.gyro.z = imu.gyro.z - imu_offset_data.gyro.z;

		imu.euler.yaw = imu.euler.yaw - imu_offset_data.euler.yaw;
		imu.euler.pitch = imu.euler.pitch - imu_offset_data.euler.pitch;
		imu.euler.roll = imu.euler.roll - imu_offset_data.euler.roll;

		imu.lineer_accel.x = imu.lineer_accel.x - imu_offset_data.lineer_accel.x;
		imu.lineer_accel.y = imu.lineer_accel.y - imu_offset_data.lineer_accel.y;
		imu.lineer_accel.z = imu.lineer_accel.z - imu_offset_data.lineer_accel.z;
	}
	imu.accel.resultant = sqrt(pow(imu.accel.x, 2) + pow(imu.accel.y, 2) + pow(imu.accel.z, 2));
	return (&imu);
}

void empty_imu_registers()
{
	uint16_t ctr;
	for (ctr = 0; ctr < EMPTY_REG_VALUE; ctr++)
	{
		get_imu_data(&imu);
	}
}

void get_offset_data(IMU *temp_imu_offset_data)
{
	uint16_t ctr;
	IMU offset_data;
	for (ctr = 0; ctr < bno055.offset_val; ctr++)
	{
		get_imu_data(&offset_data);
		temp_imu_offset_data->accel.x = temp_imu_offset_data->accel.x + offset_data.accel.x;
		temp_imu_offset_data->accel.y = temp_imu_offset_data->accel.y + offset_data.accel.y;
		temp_imu_offset_data->accel.z = temp_imu_offset_data->accel.z + offset_data.accel.z;

		temp_imu_offset_data->gyro.x = temp_imu_offset_data->gyro.x + offset_data.gyro.x;
		temp_imu_offset_data->gyro.y = temp_imu_offset_data->gyro.y + offset_data.gyro.y;
		temp_imu_offset_data->gyro.z = temp_imu_offset_data->gyro.z + offset_data.gyro.z;

		temp_imu_offset_data->euler.yaw = temp_imu_offset_data->euler.yaw + offset_data.euler.yaw;
		temp_imu_offset_data->euler.pitch = temp_imu_offset_data->euler.pitch + offset_data.euler.pitch;
		temp_imu_offset_data->euler.roll = temp_imu_offset_data->euler.roll + offset_data.euler.roll;

		temp_imu_offset_data->lineer_accel.x = temp_imu_offset_data->lineer_accel.x + offset_data.lineer_accel.x;
		temp_imu_offset_data->lineer_accel.y = temp_imu_offset_data->lineer_accel.y + offset_data.lineer_accel.y;
		temp_imu_offset_data->lineer_accel.z = temp_imu_offset_data->lineer_accel.z + offset_data.lineer_accel.z;
	}

	temp_imu_offset_data->accel.x /= OFFSET_VALUE;
	temp_imu_offset_data->accel.y /= OFFSET_VALUE;
	temp_imu_offset_data->accel.z /= OFFSET_VALUE;

	temp_imu_offset_data->gyro.x /= OFFSET_VALUE;
	temp_imu_offset_data->gyro.y /= OFFSET_VALUE;
	temp_imu_offset_data->gyro.z /= OFFSET_VALUE;

	temp_imu_offset_data->euler.yaw /= OFFSET_VALUE;
	temp_imu_offset_data->euler.pitch /= OFFSET_VALUE;
	temp_imu_offset_data->euler.roll /= OFFSET_VALUE;

	temp_imu_offset_data->lineer_accel.x /= OFFSET_VALUE;
	temp_imu_offset_data->lineer_accel.y /= OFFSET_VALUE;
	temp_imu_offset_data->lineer_accel.z /= OFFSET_VALUE;
}

uint8_t check_imu_connection(){
	uint8_t id;
	imu_read_register(bno055.chip_id_reg,&id,1);
	return (id == bno055.chip_id) ? DEV_OK : DEV_ERR;
}

uint8_t check_imu_status(){
	uint8_t reg_data;
	imu_read_register(bno055.sys_status,&reg_data,1);
	return reg_data;
}
